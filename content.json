{"pages":[],"posts":[{"title":"Java基础-继承","text":"继承类、超类和子类定义子类1class Manager extends Employee // Manager继承了Employee 覆盖（override）当超类中的一些方法对于子类并不适用时，可以提供新的方法来覆盖（override）超类中的方法。需要注意的是，子类中的方法不能直接访问超类中的私有域。例如，尽管每个Manager对象都拥有一个名为salary的域（继承自Employee），但在Manager类的方法中并不能直接访问它，只有Employee类的方法才能访问私有部分，因此Manager类需要借助公有借口访问salary。 1234public double getSalary(){ double baseSalary = super.getSalary(); //调用超类方法 return baseSalary + bonus;} 子类可以增加域，增加方法或是覆盖超类方法，但不能删除继承的域和方法。 子类构造器1234public Manager(String name, double salary, int year, int month, int day){ super(name, salary, year, month, day); // 调用超类Employee中含有, salary, year, month, day参数的构造器 bounus = 0;} 因为子类构造器不能访问超类的私有域，所以必须利用超类的构造器对这部分私有域就行初始化，可以通过super实现对超类构造器的调用。 如果子类的构造器没有显式地调用超类的构造器，则将自动的调用超类默认的构造器。 tips： this的两个用途：引用隐式参数、调用该类其他的构造器； super的两个用途：调用超类的方法、调用超类的构造器。 一个对象变量可以指示多种实际类型的现象被称为多态，在运行时能够自动地选择调用哪个方法的现象称为动态绑定。 多态出现超类对象的任何地方都可以用子类对象置换。例如： 123Employee e;e = new Employee(...);e = new Manager(...); 在Java中，对象变量是多态的，一个超类变量既可以引用超类对象，也可以引用该超类的任何一个子类的对象。 方法调用static方法又被称为静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的。并且在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。因此，如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。最常见的static方法是main方法。 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。 static代码块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 阻止继承：final类和方法不允许扩展的类被称为final类。类中的特定方法也可以被声明为final类，这样做可以让子类不能覆盖该方法。final类中的所有方法被自动设为final方法。 强制类型转换 只能在继承层次内进行类型转换 在将超类转换成子类之前，应该使用instanceof进行检查 example： 1234if (staff[1] instanceof Manager){ boss = (Manager) staff[1]; ...} 抽象类将抽象类作为派生其他类的基类，而不作为被使用的特定的实例类。 抽象方法充当着站位的角色，它们的具体实现在子类中。 扩展抽象类的两种选择： 在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类； 定义全部抽象方法，这样子类就不是抽象类了。 tip：可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 受保护访问 仅对本类可见：private； 对所有类可见：public； 对本包和所有子类可见：protected。 Object：所有类的超类equals方法Object类中的equals方法用于检测一个对象是否等于另一个对象（判断两个对象是否具有相同的引用），但对大多数类来说，这种判断没什么意义，通常需要检测两个对象状态的相等性。 在子类中定义equals方法时，首先要调用超类的equals。如果检测失败，对象就不可能相等，如果超类中的域都相等，就需要比较子类中的域。 1234public boolean equals(Object otherObject){ if (!super.equals(otherObject)) return false; ...} 如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测 如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较。 泛型数组列表ArrayList是一个采用类型参数的泛型类，具有自动调节数组容量的功能。 12345ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();staff.add(...);staff.remove(...);staff.get(i); // 访问第i个元素staff.set(i, ...) // 替换第i个元素 在确定数组列表大小不会改变时，可以调用trimToSize方法，调整存储区域大小。 对象包装器与自动装箱对象包装器类：与基本类型对应的类。对象包装器类是不可变的，并不能定义他们的子类。 编译器将自动的插入一条对象拆箱的指令（例如，Integer–&gt;int），然后进行计算，最后将结果装箱。此外，装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。 参数数量可变的方法example: 1234567public static double max(double... values){ double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest;} 反射能够分析类能力的程序称为反射（通过Class实例获取类信息的方法）。 Class类Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪这每个对象所属的类。保存这些信息的类称为Class。 每加载一种类，JVM就为其创建一个Class类型的实例，并关联起来。 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后为String类创建一个Class实例并关联起来： 1Class cls = new Class(String); 一个Class实例包含了该类的所有完整信息： 1234567891011121314graph LR; subgraph one; Class实例; name=Java.lang.String; package=java.lang; super=java.lang.Object; iterface=CharSequence...; filed=hash...; method=indexOf... end subgraph two; String; end Class实例 --&gt; String 因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的类的所有信息。 tip：因为Class实例在JVM中是唯一的。可以用==比较两个Class实例。 如何获得Class实例： 123Class cl = xxx.getClass();Class cl = Class.forName(java.util.Random); // 静态方法forNameClass cl = Random.class; 一种创建对象的方法： 12Class cl = xxx.getClass();Object m = cl.newInstance(); // 缺点：只能调用无参数的构造器进行初始化 捕获异常当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止。 将可能抛出已检查异常的一个或多个方法调用代码放在try块中，然后在catch子句中提供处理器代码。 123456try{ ...}catch (Exception e){ ...} 利用反射分析类可以利用反射机制检查类的结构。 在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。 Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，包括超类的公有成员。getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，包括私有和受保护成员，但不包括超类的成员。 在运行时使用反射分析对象查看任意对象的数据域名称和类型： 获得对应的Class对象； 通过Class对象调用getDeclaredFields。 利用反射机制可以查看在编译时还不清楚的对象域。查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象（例如，通过getDeclaredFields得到的对象），obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域的当前值。 1234Employee harry = new Employee(name = &quot;Harry&quot;, ...);Class cl = harry.getClass(); // Employee类的Class对象Field f = cl.getDeclaredField(&quot;name&quot;); // Employee类的‘name’域的对象Object v = f.get(harry); // harry这一对象的name域的值 反射机制的默认行为受限于Java的访问控制，如果一个Java程序没有收到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，需要调用Field、Method或Constructor对象的setAccessible方法。 1234f.setAccessible(true); // 将所有的域设置为可访问的f.get(obj);f.set(obj, value) // 将obj对象的f域设置成新值 使用通用的toString方法实现自己类中的toString方法： 123public String toString(){ return new ObjectAnalyzer().toString(this); } 使用反射编写泛型Java数组会记住每个元素的类型，即创建数组时new表达式使用的元素类型。将一个Employee[]临时地转换成Object[]数组，然后转换回去是可以的，但是一个从开始就是Object[]的数组却永远不能转换成Employee[]数组。为了编写通用的数组代码，需要能够创建与原数组类型相同的新数组。为此需要利用java.lang.reflect中Array类。 整型数组类型int[]可以被转换成Object，但不能转换成对象数组。 调用任意方法（方法指针）在Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。 invoke的参数和返回值必须是Object类型。此外，使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。","link":"/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/"}],"tags":[{"name":"Java核心技术卷I","slug":"Java核心技术卷I","link":"/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"基础","slug":"Java/基础","link":"/categories/Java/%E5%9F%BA%E7%A1%80/"}]}