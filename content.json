{"pages":[],"posts":[{"title":"Java基础-接口","text":"接口、lambda表达式与内部类接口：描述类具有什么功能，但并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。 lambda表达式：表示可以在将来某个时间点执行的代码块的简洁方法。 内部类：定义在另外一个类的内部，其中的方法可以访问包含它们的外部类的域。 代理：实现任意接口的对象。 接口接口概念接口并不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。 123public interface Comparable{ int compareTo(Object other);} 任何实现Comparable的类都需要包含compareTo方法。 接口决不能含有实数域或静态方法，但是可以包含常量。 类实现一个接口通常需要两个步骤： 将类声明为实现给定的接口； 1class Empployee implements Comparable&lt;Employee&gt; //泛型Comparable接口 对接口中的所有方法进行定义。 接口的特性不能构造接口的对象，但是能声明接口变量，接口变量必须引用实现了接口的类对象。 接口与抽象类类可以实现多个接口，但不能继承多个超类。 默认方法可以为接口方法提供一个默认实现。用default标记这样的方法。 123public interface Comparable&lt;T&gt;{ default int compareTo(T other) {return 0;}} 默认方法可以调用任何其他方法。 默认方法可以应对“接口演化”现象（接口新增了其他新方法）。 解决默认方法冲突 超类优先。如果超类提供了一个具体方法，同名切具有相同参数类型的默认方法会被忽略。 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名且参数类型相同的方法，必须覆盖这个方法来解决冲突。 接口示例接口与回调回调：指出某个特定事件发生时应采取的动作。 对象克隆 默认的clone方法是否满足要求； 是否可以在可变的子对象上调用clone来修补默认的clone方法。 无论选择哪种选项，类必须： 实现Cloneable接口； 重新定义clone方法，并制定**public**访问修饰符。 lambda表达式lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。无需指定lambda表达式的返回类型，其返回类型总是会由上下文推导得出。 函数式接口对于只有一个抽象方法的接口（单方法接口），需要这种接口的对象时，可以提供一个lambda表达式。这种接口称为函数式接口。 1Arrays.sort(words, (first, second) -&gt; first.length() - second.length()); lambda表达式可以转换为接口。 12345Timer t = new Timer(1000, event -&gt; { System.out.println(&quot;The time is &quot; + new Date()); Toolkit.getDefaultToolkit().beep();}); 要用::操作符分隔方法名与对象或类名，主要分为以下三种情况： object::instanceMethod Class::staticMethod Class::instanceMethod 在前两种情况中，方法引用等价于提供方法参数的lambda表达式。对于第三种情况，第一个参数会成为方法的目标。 变量作用域lambda表达式有三部分： 一个代码块； 参数； 自由变量的值。 lambda表达式可以捕获外围作用域中变量的值，在lambda表达式中，只能引用值不会改变的变量（不管是在lambda内部改变或是在外部改变都不行）。lambda表达式中捕获的变量必须实际上是最终变量。 在lambda表达式中使用this关键字，是指创建这个lambda表达式的方法的this参数。 处理lambda表达式使用lambda表达式的重点是延迟执行，其理由是： 在一个单独的线程中运行代码； 多次运行代码； 在算法的适当位置运行代码； 发生某种情况时执行代码； 只有在必要时才运行代码。 内部类内部类是定义在另一个类中的类。 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据； 内部类可以对同一包的其他类隐藏起来（私有类）； 使用匿名内部类定义一个回调函数更方便。 使用内部类访问对象状态1234567public class TalkingClock { ... public class TimePrinter implements ActionListener // 内部类 { ... }} TimePrinter类位于TalkingClock类内部，这并不意味着每个TalkingClock都有一个TimePrinter实例域，TimePrinter对象是由TalkingClock类的方法构造。 内部类的对象总有一个隐形引用，它指向了创建它的外部类对象。外围类的引用在内部类的构造器中设置，编译器修改了所有的内部类的构造器，添加了一个外围类引用的参数。 内部类是否有用、必要和安全内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，虚拟机对此并不知情。 编译器会在外围类添加静态方法access$0，它会返回作为参数传递给它的外部类的对象域。如果内部类访问了私有数据域，就有可能通过附加在外围类所在包中的其他类访问他们。 局部内部类局部类不能用public或private访问说明符进行声明，它的作用域被限定在声明这个局部类的块中。好处是除了定义他的方法外，没有任何方法指导局部类的存在。 由外部方法访问变量局部类不仅能够访问包含它们的外部类，还可以访问外部类的局部变量，但是局部变量必须为final，一旦赋值就不会改变。 编译器会检测对局部变量的访问，为每一个变量建立相应的数据域，并将局部变量拷贝到构造器中，以便将这些数据域初始化为局部变量的副本。 匿名内部类假如只创建这个类的一个对象，就不用命名了，这种类被称为匿名内部类。 通常的语法格式： 123new SuperType(construction parameters){ inner class method and data} SuperType如果是接口，内部类就要实现这个接口；如果是一个类，就要扩展他。 因为匿名类没有类名，因此匿名类不能有构造器。取而代之的是将构造器参数传递给超类构造器。 静态内部类当使用内部类只是为了隐藏该类，不需要其引用外围类对象时，可以将该内部类声明为static，以便取消产生的引用。 代理利用代理可以在运行时创建一个实现了一组给定接口的新类。当在编译时无法确定需要实现哪个接口时可以使用代理。 为其他对象提供一种代理以控制对这个对象的访问。 代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。 使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。 何时使用代理代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口。它具有下列方法： 指定接口所需要的全部方法； Object类中的全部方法，例如toString,equals等。 但是不能在运行时定义这些方法的新代码，而是要提供一个调用处理器。调用处理器是实现了**InvocationHandler**接口的类对象。在这个接口这只有一个方法：Object invoke(Object proxy, Method method, Object[] args)。 无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。 创建代理对象需要使用Proxy类的newProxyInstance方法创建一个代理对象。该方法总共有三个参数： 一个类加载器； 一个Class对象数组，每个元素都是需要实现的接口； 一个调用处理器。 代理类的特性值得注意的是，代理类是在程序运行过程中创建的；但是一旦被创建就变成了常规类，与虚拟机中的其他类并无区别。 所有的代理类都扩展于Proxy类。一个代理类只有一个实例域——调用处理器，它定义在Proxy的超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。 所有的代理类都覆盖了Object类中的toString、equals和hashCode方法。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的invoke。 在Sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名。 对于特定的类加载器和预设的一组接口来说，只能有一个代理类。换句话说，如果使用同一个类加载器和接口数组调用两次newProxyInstance方法的话，那么只能够得到同一个类的两个对象。或者也可以采用getProxyClass方法获得这个类。 静态代理为现有的类编写一个对应的代理类，并且让它实现和目标类相同的接口。在常见代理对象是，通过构造器塞入一个目标对象，然后在代理对象的方法的内容调用目标对象同名的方法，并添加所需的增强代码。 缺点：需要为每一个目标类编写对应的代理类。 动态代理通过直接得到代理Class对象，创建代理实例。 代理类和目标类理应实现同一组接口，从而尽可能确保代理对象的内部结构和目标对象一致，这样对代理对象的操作最终都能够转移到目标对象上，代理对象只需要关注增强代码的编写。 因此可以说：接口拥有代理对象和目标对象共同的类信息。所以可以尝试从接口获得理应由代理类提供的信息。 使用java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类完成动态代理。 通过调用Proxy类的静态方法getProxyClass(ClassLoader, interfaces)可以创建代理Class，从而创建代理对象。ClassLoader：类加载器，interfaces：需要实现的接口的class对象。 根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法： 通过构造器传入一个引用，而代理对象的内部存在一个成员变量invocationHandler，代理对象的每个方法内部都会调用handler.invoke()，invocationHandler对象成为了代理对象和目标对象之间的桥梁。 123456789101112131415161718192021222324252627public class ProxyTest { public static void main(String[] args) throws Throwable { CalculatorImpl target = new CalculatorImpl(); //传入目标对象 //目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法 Calculator calculatorProxy = (Calculator) getProxy(target); calculatorProxy.add(1, 2); calculatorProxy.subtract(2, 1); } private static Object getProxy(final Object target) throws Exception { //参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口 Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces()); Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class); Object proxy = constructor.newInstance(new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + &quot;方法开始执行...&quot;); Object result = method.invoke(target, args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;); return result; } }); return proxy; }} 利用以上代码，无论系统有多少类，只要传进实例，getProxy方法都可以返回对应的代理对象。 而在实际编程中，一般不使用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例。 12345678910111213141516171819202122232425public class ProxyTest { public static void main(String[] args) throws Throwable { CalculatorImpl target = new CalculatorImpl(); Calculator calculatorProxy = (Calculator) getProxy(target); calculatorProxy.add(1, 2); calculatorProxy.subtract(2, 1); } private static Object getProxy(final Object target) throws Exception { Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(),/*类加载器*/ target.getClass().getInterfaces(),/*让代理对象和目标对象实现相同接口*/ new InvocationHandler(){/*代理对象的方法最终都会被JVM导向它的invoke方法*/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName() + &quot;方法开始执行...&quot;); Object result = method.invoke(target, args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;); return result; } } ); return proxy; }} 代理Class其实就是附有构造器的接口Class，一样的类结构信息却能够创建实例。 动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法。","link":"/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/"},{"title":"Java基础-继承","text":"继承类、超类和子类定义子类1class Manager extends Employee // Manager继承了Employee 覆盖（override）当超类中的一些方法对于子类并不适用时，可以提供新的方法来覆盖（override）超类中的方法。需要注意的是，子类中的方法不能直接访问超类中的私有域。例如，尽管每个Manager对象都拥有一个名为salary的域（继承自Employee），但在Manager类的方法中并不能直接访问它，只有Employee类的方法才能访问私有部分，因此Manager类需要借助公有借口访问salary。 1234public double getSalary(){ double baseSalary = super.getSalary(); //调用超类方法 return baseSalary + bonus;} 子类可以增加域，增加方法或是覆盖超类方法，但不能删除继承的域和方法。 子类构造器1234public Manager(String name, double salary, int year, int month, int day){ super(name, salary, year, month, day); // 调用超类Employee中含有, salary, year, month, day参数的构造器 bounus = 0;} 因为子类构造器不能访问超类的私有域，所以必须利用超类的构造器对这部分私有域就行初始化，可以通过super实现对超类构造器的调用。 如果子类的构造器没有显式地调用超类的构造器，则将自动的调用超类默认的构造器。 tips： this的两个用途：引用隐式参数、调用该类其他的构造器； super的两个用途：调用超类的方法、调用超类的构造器。 一个对象变量可以指示多种实际类型的现象被称为多态，在运行时能够自动地选择调用哪个方法的现象称为动态绑定。 多态出现超类对象的任何地方都可以用子类对象置换。例如： 123Employee e;e = new Employee(...);e = new Manager(...); 在Java中，对象变量是多态的，一个超类变量既可以引用超类对象，也可以引用该超类的任何一个子类的对象。 方法调用static方法又被称为静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的。并且在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。因此，如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。最常见的static方法是main方法。 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。 static代码块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 阻止继承：final类和方法不允许扩展的类被称为final类。类中的特定方法也可以被声明为final类，这样做可以让子类不能覆盖该方法。final类中的所有方法被自动设为final方法。 强制类型转换 只能在继承层次内进行类型转换 在将超类转换成子类之前，应该使用instanceof进行检查 example： 1234if (staff[1] instanceof Manager){ boss = (Manager) staff[1]; ...} 抽象类将抽象类作为派生其他类的基类，而不作为被使用的特定的实例类。 抽象方法充当着站位的角色，它们的具体实现在子类中。 扩展抽象类的两种选择： 在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类； 定义全部抽象方法，这样子类就不是抽象类了。 tip：可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 受保护访问 仅对本类可见：private； 对所有类可见：public； 对本包和所有子类可见：protected。 Object：所有类的超类equals方法Object类中的equals方法用于检测一个对象是否等于另一个对象（判断两个对象是否具有相同的引用），但对大多数类来说，这种判断没什么意义，通常需要检测两个对象状态的相等性。 在子类中定义equals方法时，首先要调用超类的equals。如果检测失败，对象就不可能相等，如果超类中的域都相等，就需要比较子类中的域。 1234public boolean equals(Object otherObject){ if (!super.equals(otherObject)) return false; ...} 如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测 如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较。 泛型数组列表ArrayList是一个采用类型参数的泛型类，具有自动调节数组容量的功能。 12345ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();staff.add(...);staff.remove(...);staff.get(i); // 访问第i个元素staff.set(i, ...) // 替换第i个元素 在确定数组列表大小不会改变时，可以调用trimToSize方法，调整存储区域大小。 对象包装器与自动装箱对象包装器类：与基本类型对应的类。对象包装器类是不可变的，并不能定义他们的子类。 编译器将自动的插入一条对象拆箱的指令（例如，Integer–&gt;int），然后进行计算，最后将结果装箱。此外，装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。 参数数量可变的方法example: 1234567public static double max(double... values){ double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest;} 反射能够分析类能力的程序称为反射（通过Class实例获取类信息的方法）。 Class类Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪这每个对象所属的类。保存这些信息的类称为Class。 每加载一种类，JVM就为其创建一个Class类型的实例，并关联起来。 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后为String类创建一个Class实例并关联起来： 1Class cls = new Class(String); 一个Class实例包含了该类的所有完整信息： 1234567891011121314graph LR; subgraph one; Class实例; name=Java.lang.String; package=java.lang; super=java.lang.Object; iterface=CharSequence...; filed=hash...; method=indexOf... end subgraph two; String; end Class实例 --&gt; String 因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的类的所有信息。 tip：因为Class实例在JVM中是唯一的。可以用==比较两个Class实例。 如何获得Class实例： 123Class cl = xxx.getClass();Class cl = Class.forName(java.util.Random); // 静态方法forNameClass cl = Random.class; 一种创建对象的方法： 12Class cl = xxx.getClass();Object m = cl.newInstance(); // 缺点：只能调用无参数的构造器进行初始化 捕获异常当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止。 将可能抛出已检查异常的一个或多个方法调用代码放在try块中，然后在catch子句中提供处理器代码。 123456try{ ...}catch (Exception e){ ...} 利用反射分析类可以利用反射机制检查类的结构。 在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。 Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，包括超类的公有成员。getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，包括私有和受保护成员，但不包括超类的成员。 在运行时使用反射分析对象查看任意对象的数据域名称和类型： 获得对应的Class对象； 通过Class对象调用getDeclaredFields。 利用反射机制可以查看在编译时还不清楚的对象域。查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象（例如，通过getDeclaredFields得到的对象），obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域的当前值。 1234Employee harry = new Employee(name = &quot;Harry&quot;, ...);Class cl = harry.getClass(); // Employee类的Class对象Field f = cl.getDeclaredField(&quot;name&quot;); // Employee类的‘name’域的对象Object v = f.get(harry); // harry这一对象的name域的值 反射机制的默认行为受限于Java的访问控制，如果一个Java程序没有收到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，需要调用Field、Method或Constructor对象的setAccessible方法。 1234f.setAccessible(true); // 将所有的域设置为可访问的f.get(obj);f.set(obj, value) // 将obj对象的f域设置成新值 使用通用的toString方法实现自己类中的toString方法： 123public String toString(){ return new ObjectAnalyzer().toString(this); } 使用反射编写泛型Java数组会记住每个元素的类型，即创建数组时new表达式使用的元素类型。将一个Employee[]临时地转换成Object[]数组，然后转换回去是可以的，但是一个从开始就是Object[]的数组却永远不能转换成Employee[]数组。为了编写通用的数组代码，需要能够创建与原数组类型相同的新数组。为此需要利用java.lang.reflect中Array类。 整型数组类型int[]可以被转换成Object，但不能转换成对象数组。 调用任意方法（方法指针）在Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。 invoke的参数和返回值必须是Object类型。此外，使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。","link":"/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/"},{"title":"Java基础-部分关键字总结","text":"访问控制不使用任何关键字使用默认访问修饰符声明的变量和方法，对于同一个包内的其他类是可见的。 private被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 声明为private的变量只能通过类中公共的getter方法被外部类访问，既不能通过对象.变量的形式直接访问。 private主要用于隐藏类的实现细节以及保护类的数据。 public被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 由于类的继承性，类所有的公有方法和变量都能被其子类继承。但是如果超类中有访问私有变量的public或者protected方法，子类可以通过这些方法使用这些私有变量（“A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.”——摘自官方文档）。 以上说法是从继承的概念出发，private变量不能被继承，因为子类无法直接访问这些private成员。但是从内存的角度思考，子类会继承超类所有方法，变量和嵌套类（构造函数不能继承），因此可以利用super实现对超类构造器的调用或者调用super.setter，从而对这部分私有域进行赋值，也可以调用super.setter或者super.getter对这类变量进行访问和修改。 protectedprotected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。接口及接口的成员变量和成员方法不能声明为 protected。 protected需要从以下两点进行分析： 超类的protected成员是包内可见的，并且对子类可见； 如果超类和子类不在同一包中，那么在子类中，子类实例可以访问其从超类继承而来的protected方法，但是不能访问超类的protected方法。 涉及到protected成员调用时，首先要确定该成员来自何方，其可见性范围是什么，然后才能判断当前使用是否正确。protected这一块坑还是挺多的，在此贴一个代码案例链接方便理解（https://blog.csdn.net/justloveyou_/article/details/61672133）。 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问控制static 静态变量：用于声明独立于对象的静态变量，无论实例化多少对象，该类的静态变量只有一份拷贝。静态变量也被称为类变量，局部变量不能被声明为static。 静态方法：用于声明独立于对象的静态方法，可以不实例化对象而直接使用这类方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据并用于计算。 final final变量：变量一旦赋值后就不能被重新赋值。被final修饰的实例变量必须显式指定初始值。 final方法：父类中的final方法可以被子类继承，但不能被子类重写。 final类：不能被继承。 abstract 抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。抽象类可以同时包含抽象方法和非抽象方法。 抽象方法：抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 synchronizedsynchronized 关键字声明的方法同一时间只能被一个线程访问。 transient序列化的对象包含被 transient 修饰的实例变量时，JVM会跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatilevolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。","link":"/2020/12/26/Java%E5%9F%BA%E7%A1%80-%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"},{"title":"Java基础-泛型程序设计","text":"泛型程序设计为什么使用泛型程序设计泛型程序设计意味着编写的代码可以被很多不同类型的对象所用。 类型参数的好处ArrayList类有一个类型参数用来指示元素的类型。 类型参数让程序具有更好的可读性和安全性 定义简单泛型类一个泛型类就是具有一个或多个类型变量的类。 123public class xxx&lt;T&gt; { ...} 泛型方法123456class ArrayAlg { public static &lt;T&gt; T getMiddle(...) { ... }}String middle = ArrayAlg.getMiddle(...); 类型变量放在修饰符的后面（public static），返回类型的前面。 类型变量的限定对类型变量设置限定： 1public static &lt;T extends Comparable&gt; T ... 泛型代码和虚拟机 虚拟机没有泛型类型对象，所有对象都属于普通类（类型擦除）； 所有的类型参数都用它们的限定类型替换； 桥方法被合成来保持多态； 为保持类型安全性，必要时插入强制类型转换。 无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（无限定的变量原始类型为Object）。 可以利用反射绕过编译器对泛型对象进行操作。 约束与局限性 不能用基本类型（eg. String、char）实例化类型参数; 运行时类型查询只适用于原始类型； 不能创建参数化类型的数组（new Pair[10]）； Varargs警告； 不能实例化类型变量（new T(…)）； 不能构造泛型数组（T[]）； 泛型类的静态上下文中类型变量无效，即不能再静态域或方法中引用类型变量； 不能抛出或捕获泛型类的实例； 可以利用泛型消除对受查异常的检查； 泛型类型的继承规则无论S类和T类有什么联系，通常Pair和Pair之间是没有联系的。 永远可以将参数化类型转换为一个原始类型。例如，Pair是原始类型Pair的一个子类型。 此外，泛型类型可以扩展或实现其他的泛型类。 通配符类型通配符概念通配符类型中，允许类型参数变化。例如Pair&lt;? extends Employee&gt;表示任何泛型Pair类型，它的类型参数是Employee的子类。而类型Pair是Pair&lt;? extends Employee&gt;的子类型。 以下调用第一种是可行的，而第二种调用中，编译器只知道需要某个Employee的子类型但不知道具体类型，因此拒绝传递任何特定的类型。即可以为方法提供返回值，但不能提供参数。 12? extends Employee getFirst()void setFirst(? extends Employee) 因此我们可以得出区分安全的访问器方法和不安全的更改器方法。 通配符的超类型限定超类型限定：? super Manganer 这个通配符限制为Manager的所有超类型，这样做可以为方法提供参数，但是不能使用返回值。 直观的讲，带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。 一般来说，当使用时需要频繁的插入数据，就用超类型限定，需要获取数据，就是用子类型限定。 无限定通配符例如Pair&lt;?&gt;。与Pair的区别在于：可以用任意Object对象调用原始Pair类的setObject方法（但是只能调用setObject(null)）。 通配符捕获123456void foo (List&lt;?&gt; i) { fooHelper(i);}private &lt;T&gt; void fooHelper(List&lt;T&gt; l) { l.set(0, l.get(0));} 当不使用帮助器直接调用set时，编译器无法确认被插入到列表中的对象的类型。而利用辅助方法，编译器使用推理来确定T是调用中的捕获变量。 反射和泛型泛型Class类Class, Constructor 使用Class参数进行类型匹配1234public static &lt;T&gt; pair&lt;T&gt; makePair(Class&lt;T&gt; c) throws InstantiationExceotion, IllegalAccessException { return new Pair&lt;&gt;(c.newInstance(), c.newInstance());}makePair(Emplouee.class) 虚拟机中的泛型类型信息为了表达泛型类型声明，使用reflect包中提供的接口Type。","link":"/2021/01/08/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java核心技术卷I","slug":"Java核心技术卷I","link":"/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"基础","slug":"Java/基础","link":"/categories/Java/%E5%9F%BA%E7%A1%80/"}]}