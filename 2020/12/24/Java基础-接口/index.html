<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java基础-接口 - 混子的个人修养</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="混子的个人修养"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="混子的个人修养"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="Java基础——接口与内部类笔记"><meta property="og:type" content="blog"><meta property="og:title" content="Java基础-接口"><meta property="og:url" content="http://example.com/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/"><meta property="og:site_name" content="混子的个人修养"><meta property="og:description" content="Java基础——接口与内部类笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic1.zhimg.com/80/v2-ba3d9206f341be466f18afbdd938a3b3_720w.jpg?source=1940ef5c"><meta property="og:image" content="https://pic1.zhimg.com/v2-88147b81ee9342015374159b2671320b_r.jpg?source=1940ef5c"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-92610586e77cf71ba5ce89087de52ff1_720w.jpg?source=1940ef5c"><meta property="og:image" content="https://pic1.zhimg.com/v2-b5fc8b279a6152889afdfedbb0f611cc_r.jpg?source=1940ef5c"><meta property="og:image" content="https://pic4.zhimg.com/v2-6aacbe1e9df4fe982a68fe142401952e_r.jpg?source=1940ef5c"><meta property="og:image" content="https://pic2.zhimg.com/v2-991ea99b9038d52875ff6ba57e9032de_r.jpg?source=1940ef5c"><meta property="article:published_time" content="2020-12-24T14:57:29.000Z"><meta property="article:modified_time" content="2020-12-24T15:06:51.618Z"><meta property="article:author" content="Arthur Liu"><meta property="article:tag" content="Java核心技术卷I"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://pic1.zhimg.com/80/v2-ba3d9206f341be466f18afbdd938a3b3_720w.jpg?source=1940ef5c"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/"},"headline":"混子的个人修养","image":[],"datePublished":"2020-12-24T14:57:29.000Z","dateModified":"2020-12-24T15:06:51.618Z","author":{"@type":"Person","name":"Arthur Liu"},"description":"Java基础——接口与内部类笔记"}</script><link rel="canonical" href="http://example.com/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Arthur</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ArthurLYL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-24T14:57:29.000Z" title="2020-12-24T14:57:29.000Z">2020-12-24</time>发表</span><span class="level-item"><time dateTime="2020-12-24T15:06:51.618Z" title="2020-12-24T15:06:51.618Z">2020-12-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a></span><span class="level-item">25 分钟读完 (大约3730个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java基础-接口</h1><div class="content"><h1 id="接口、lambda表达式与内部类"><a href="#接口、lambda表达式与内部类" class="headerlink" title="接口、lambda表达式与内部类"></a>接口、lambda表达式与内部类</h1><p>接口：描述类具有什么功能，但并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。</p>
<p>lambda表达式：表示可以在将来某个时间点执行的代码块的简洁方法。</p>
<p>内部类：定义在另外一个类的内部，其中的方法可以访问包含它们的外部类的域。</p>
<p>代理：实现任意接口的对象。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h3><p>接口并不是类，而是对类的一组<strong>需求描述</strong>，这些类要遵从接口描述的统一格式进行定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现<code>Comparable</code>的类都需要包含<code>compareTo</code>方法。</p>
<p>接口决不能含有<strong>实数域</strong>或<strong>静态方法</strong>，但是可以包含<strong>常量</strong>。</p>
<p>类实现一个接口通常需要两个步骤：</p>
<ul>
<li>将类声明为实现给定的接口；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empployee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; //泛型<span class="title">Comparable</span>接口</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对接口中的所有方法进行定义。</li>
</ul>
<h3 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h3><p>不能构造接口的对象，但是能声明<strong>接口变量</strong>，接口变量必须引用实现了接口的类对象。</p>
<h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>类可以实现多个接口，但不能继承多个超类。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>可以为接口方法提供一个默认实现。用<code>default</code>标记这样的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认方法可以调用任何其他方法。</p>
<p>默认方法可以应对“接口演化”现象（接口新增了其他新方法）。</p>
<h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><ul>
<li>超类优先。如果超类提供了一个具体方法，同名切具有相同参数类型的默认方法会被忽略。</li>
<li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名且参数类型相同的方法，必须<strong>覆盖</strong>这个方法来解决冲突。</li>
</ul>
<h2 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h2><h3 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h3><p>回调：指出某个特定事件发生时应采取的动作。</p>
<h3 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h3><ul>
<li>默认的<code>clone</code>方法是否满足要求；</li>
<li>是否可以在可变的子对象上调用<code>clone</code>来修补默认的<code>clone</code>方法。</li>
</ul>
<p>无论选择哪种选项，类必须：</p>
<ul>
<li>实现<code>Cloneable</code>接口；</li>
<li>重新定义<code>clone</code>方法，并制定**<code>public</code>**访问修饰符。</li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。无需指定lambda表达式的返回类型，其返回类型总是会由上下文推导得出。</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只有一个<strong>抽象方法</strong>的<strong>接口</strong>（单方法接口），需要这种接口的<strong>对象</strong>时，可以提供一个lambda表达式。这种接口称为<strong>函数式接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>
<p>lambda表达式可以转换为接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, </span><br><span class="line">	event -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;The time is &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">	Toolkit.getDefaultToolkit().beep();&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>要用<code>::</code>操作符分隔方法名与对象或类名，主要分为以下三种情况：</p>
<ul>
<li><code>object::instanceMethod</code></li>
<li><code>Class::staticMethod</code></li>
<li><code>Class::instanceMethod</code></li>
</ul>
<p>在前两种情况中，方法引用等价于提供方法参数的lambda表达式。对于第三种情况，第一个参数会成为方法的目标。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>lambda表达式有三部分：</p>
<ul>
<li>一个代码块；</li>
<li>参数；</li>
<li>自由变量的值。</li>
</ul>
<p>lambda表达式可以捕获外围作用域中变量的值，在lambda表达式中，只能引用值不会改变的变量（不管是在lambda内部改变或是在外部改变都不行）。lambda表达式中捕获的变量必须实际上是<strong>最终变量</strong>。</p>
<p>在lambda表达式中使用<code>this</code>关键字，是指创建这个lambda表达式的方法的<code>this</code>参数。</p>
<h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>使用lambda表达式的重点是<strong>延迟执行</strong>，其理由是：</p>
<ul>
<li>在一个单独的线程中运行代码；</li>
<li>多次运行代码；</li>
<li>在算法的适当位置运行代码；</li>
<li>发生某种情况时执行代码；</li>
<li>只有在必要时才运行代码。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是定义在另一个类中的类。</p>
<ul>
<li>内部类<strong>方法</strong>可以访问该类定义所在的作用域中的数据，包括私有的数据；</li>
<li>内部类可以对<strong>同一包</strong>的其他类隐藏起来（私有类）；</li>
<li>使用<strong>匿名</strong>内部类定义一个回调函数更方便。</li>
</ul>
<h3 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> // 内部类</span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TimePrinter</code>类位于<code>TalkingClock</code>类内部，这并不意味着每个<code>TalkingClock</code>都有一个<code>TimePrinter</code>实例域，<code>TimePrinter</code>对象是由<code>TalkingClock</code>类的方法构造。</p>
<p>内部类的对象总有一个隐形<strong>引用</strong>，它指向了创建它的<strong>外部类</strong>对象。外围类的引用在内部类的构造器中设置，编译器修改了所有的内部类的构造器，添加了一个外围类引用的参数。</p>
<h3 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h3><p>内部类是一种<strong>编译器</strong>现象，与虚拟机无关。编译器将会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，虚拟机对此并不知情。</p>
<p>编译器会在外围类添加静态方法<code>access$0</code>，它会返回作为参数传递给它的外部类的对象域。如果内部类访问了私有数据域，就有可能通过附加在外围类所在包中的其他类访问他们。</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部类不能用<code>public</code>或<code>private</code>访问说明符进行声明，它的作用域被限定在声明这个局部类的块中。好处是除了定义他的方法外，没有任何方法指导局部类的存在。</p>
<h3 id="由外部方法访问变量"><a href="#由外部方法访问变量" class="headerlink" title="由外部方法访问变量"></a>由外部方法访问变量</h3><p>局部类不仅能够访问包含它们的外部类，还可以访问<strong>外部类</strong>的<strong>局部变量</strong>，但是局部变量必须为<code>final</code>，一旦赋值就不会改变。</p>
<p>编译器会检测对局部变量的访问，为每一个变量建立相应的数据域，并将局部变量拷贝到<strong>构造器</strong>中，以便将这些数据域初始化为局部变量的副本。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>假如只创建这个类的一个<strong>对象</strong>，就不用命名了，这种类被称为匿名内部类。</p>
<p>通常的语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)&#123;</span><br><span class="line">	inner <span class="class"><span class="keyword">class</span> <span class="title">method</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>SuperType</code>如果是<strong>接口</strong>，内部类就要实现这个接口；如果是一个<strong>类</strong>，就要扩展他。</p>
<p>因为匿名类没有类名，因此匿名类<strong>不能</strong>有构造器。取而代之的是将构造器参数传递给超类构造器。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>当使用内部类只是为了隐藏该类，不需要其引用外围类对象时，可以将该内部类声明为<code>static</code>，以便取消产生的引用。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>利用代理可以在<strong>运行时</strong>创建一个实现了一组给定接口的新类。当在编译时无法确定需要实现哪个接口时可以使用代理。</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>代理模式通过封装一个已有接口，并向调用方返回<strong>相同</strong>的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</p>
<p>使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。</p>
<h3 id="何时使用代理"><a href="#何时使用代理" class="headerlink" title="何时使用代理"></a>何时使用代理</h3><p>代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口。它具有下列方法：</p>
<ul>
<li>指定接口所需要的全部方法；</li>
<li>Object类中的全部方法，例如<code>toString</code>,<code>equals</code>等。</li>
</ul>
<p>但是不能在运行时定义这些方法的新代码，而是要提供一个<strong>调用处理器</strong>。调用处理器是实现了**<code>InvocationHandler</code>**接口的类对象。在这个接口这只有一个方法：<code>Object invoke(Object proxy, Method method, Object[] args)</code>。</p>
<p>无论何时调用<strong>代理对象</strong>的方法，调用处理器的<code>invoke</code>方法都会被调用，并向其传递<code>Method</code>对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p>
<h3 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h3><p>需要使用<code>Proxy</code>类的<code>newProxyInstance</code>方法创建一个代理对象。该方法总共有三个参数：</p>
<ul>
<li>一个类加载器；</li>
<li>一个<code>Class</code>对象数组，每个元素都是需要实现的<strong>接口</strong>；</li>
<li>一个调用处理器。</li>
</ul>
<h3 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h3><p>值得注意的是，代理类是在程序运行过程中创建的；但是一旦被创建就变成了<strong>常规类</strong>，与虚拟机中的其他类并无区别。</p>
<p>所有的代理类都扩展于<code>Proxy</code>类。一个代理类只有一个实例域——调用处理器，它定义在<code>Proxy</code>的超类中。为了履行代理对象的职责，所需要的任何<strong>附加数据</strong>都必须存储在调用处理器中。</p>
<p>所有的代理类都覆盖了<code>Object</code>类中的<code>toString</code>、<code>equals</code>和<code>hashCode</code>方法。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的<code>invoke</code>。</p>
<p>在Sun虚拟机中的<code>Proxy</code>类将生成一个以字符串<code>$Proxy</code>开头的类名。</p>
<p>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。换句话说，如果使用同一个类加载器和接口数组调用两次<code>newProxyInstance</code>方法的话，那么只能够得到同一个类的<strong>两个对象</strong>。或者也可以采用<code>getProxyClass</code>方法获得这个类。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>为现有的类编写一个对应的代理类，并且让它实现和目标类相同的接口。在常见代理对象是，通过构造器塞入一个目标对象，然后在代理对象的方法的内容调用目标对象同名的方法，并添加所需的增强代码。</p>
<p>缺点：需要为每一个目标类编写对应的代理类。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通过直接得到代理Class对象，创建代理实例。</p>
<p>代理类和目标类理应实现同一组接口，从而尽可能确保代理对象的内部结构和目标对象一致，这样对代理对象的操作最终都能够转移到目标对象上，代理对象只需要关注增强代码的编写。</p>
<p>因此可以说：接口拥有代理对象和目标对象共同的类信息。所以可以尝试从接口获得理应由代理类提供的信息。</p>
<p>使用<code>java.lang.reflect.InvocationHandler</code>接口和<code>java.lang.reflect.Proxy</code>类完成动态代理。</p>
<p>通过调用Proxy类的静态方法<code>getProxyClass(ClassLoader, interfaces)</code>可以创建代理Class，从而创建代理对象。ClassLoader：类加载器，interfaces：需要实现的接口的class对象。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ba3d9206f341be466f18afbdd938a3b3_720w.jpg?source=1940ef5c"></p>
<p><img src="https://pic1.zhimg.com/v2-88147b81ee9342015374159b2671320b_r.jpg?source=1940ef5c"></p>
<p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p>
<p><img src="https://pic2.zhimg.com/80/v2-92610586e77cf71ba5ce89087de52ff1_720w.jpg?source=1940ef5c"></p>
<p>通过构造器传入一个引用，而代理对象的内部存在一个成员变量invocationHandler，代理对象的每个方法内部都会调用handler.invoke()，invocationHandler对象成为了代理对象和目标对象之间的桥梁。</p>
<p><img src="https://pic1.zhimg.com/v2-b5fc8b279a6152889afdfedbb0f611cc_r.jpg?source=1940ef5c"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		CalculatorImpl target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">                <span class="comment">//传入目标对象</span></span><br><span class="line">                <span class="comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span></span><br><span class="line">		Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">		calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span></span><br><span class="line">		Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());</span><br><span class="line">		Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);</span><br><span class="line">		Object proxy = constructor.newInstance(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(method.getName() + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">				Object result = method.invoke(target, args);</span><br><span class="line">				System.out.println(result);</span><br><span class="line">				System.out.println(method.getName() + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用以上代码，无论系统有多少类，只要传进实例，getProxy方法都可以返回对应的代理对象。</p>
<p>而在实际编程中，一般不使用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		CalculatorImpl target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">		Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">		calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Object proxy = Proxy.newProxyInstance(</span><br><span class="line">				target.getClass().getClassLoader(),<span class="comment">/*类加载器*/</span></span><br><span class="line">				target.getClass().getInterfaces(),<span class="comment">/*让代理对象和目标对象实现相同接口*/</span></span><br><span class="line">				<span class="keyword">new</span> InvocationHandler()&#123;<span class="comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(method.getName() + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">						Object result = method.invoke(target, args);</span><br><span class="line">						System.out.println(result);</span><br><span class="line">						System.out.println(method.getName() + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> result;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/v2-6aacbe1e9df4fe982a68fe142401952e_r.jpg?source=1940ef5c"></p>
<p>代理Class其实就是附有构造器的接口Class，一样的类结构信息却能够创建实例。</p>
<p>动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法。</p>
<p><img src="https://pic2.zhimg.com/v2-991ea99b9038d52875ff6ba57e9032de_r.jpg?source=1940ef5c"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java基础-接口</p><p><a href="http://example.com/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/">http://example.com/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Arthur Liu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-12-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-12-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/">Java核心技术卷I</a><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/26/Java%E5%9F%BA%E7%A1%80-%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java基础-部分关键字总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/"><span class="level-item">Java基础-继承</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/pkq.png" alt="Arthur"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Arthur</p><p class="is-size-6 is-block">芜湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Chengdu/Shenzhen</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ArthurLYL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ArthurLYL"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#接口、lambda表达式与内部类"><span class="level-left"><span class="level-item">1</span><span class="level-item">接口、lambda表达式与内部类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#接口"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">接口</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#接口概念"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">接口概念</span></span></a></li><li><a class="level is-mobile" href="#接口的特性"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">接口的特性</span></span></a></li><li><a class="level is-mobile" href="#接口与抽象类"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">接口与抽象类</span></span></a></li><li><a class="level is-mobile" href="#默认方法"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">默认方法</span></span></a></li><li><a class="level is-mobile" href="#解决默认方法冲突"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">解决默认方法冲突</span></span></a></li></ul></li><li><a class="level is-mobile" href="#接口示例"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">接口示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#接口与回调"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">接口与回调</span></span></a></li><li><a class="level is-mobile" href="#对象克隆"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">对象克隆</span></span></a></li></ul></li><li><a class="level is-mobile" href="#lambda表达式"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">lambda表达式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#函数式接口"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">函数式接口</span></span></a></li><li><a class="level is-mobile" href="#变量作用域"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">变量作用域</span></span></a></li><li><a class="level is-mobile" href="#处理lambda表达式"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">处理lambda表达式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内部类"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">内部类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用内部类访问对象状态"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">使用内部类访问对象状态</span></span></a></li><li><a class="level is-mobile" href="#内部类是否有用、必要和安全"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">内部类是否有用、必要和安全</span></span></a></li><li><a class="level is-mobile" href="#局部内部类"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">局部内部类</span></span></a></li><li><a class="level is-mobile" href="#由外部方法访问变量"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">由外部方法访问变量</span></span></a></li><li><a class="level is-mobile" href="#匿名内部类"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">匿名内部类</span></span></a></li><li><a class="level is-mobile" href="#静态内部类"><span class="level-left"><span class="level-item">1.4.6</span><span class="level-item">静态内部类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#代理"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">代理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#何时使用代理"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">何时使用代理</span></span></a></li><li><a class="level is-mobile" href="#创建代理对象"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">创建代理对象</span></span></a></li><li><a class="level is-mobile" href="#代理类的特性"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">代理类的特性</span></span></a></li><li><a class="level is-mobile" href="#静态代理"><span class="level-left"><span class="level-item">1.5.4</span><span class="level-item">静态代理</span></span></a></li><li><a class="level is-mobile" href="#动态代理"><span class="level-left"><span class="level-item">1.5.5</span><span class="level-item">动态代理</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-26T06:33:11.000Z">2020-12-26</time></p><p class="title"><a href="/2020/12/26/Java%E5%9F%BA%E7%A1%80-%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/">Java基础-部分关键字总结</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-24T14:57:29.000Z">2020-12-24</time></p><p class="title"><a href="/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3/">Java基础-接口</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-24T08:12:48.000Z">2020-12-24</time></p><p class="title"><a href="/2020/12/24/Java%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF/">Java基础-继承</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/"><span class="tag">Java核心技术卷I</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Arthur</a><p class="is-size-7"><span>&copy; 2021 Arthur Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ArthurLYL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>